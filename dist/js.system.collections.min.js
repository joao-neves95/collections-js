class Errors{static get existingKey(){throw new Error("An item with the same key has already been added.")}static get noTypeProvided(){throw new Error("No type provided on Collection instantiation.")}static wrongType(e){throw new Error(`The value is not from the same type as the List<${e}>`)}}try{module.exports=Errors}catch(e){}let ____errors0,____errors1,____collection1,____errors2,____collection2;try{____errors0=require("./errors")}catch(e){____errors0=Errors}class Collection{constructor(e=!1,t="any"){if(this.elements=[],this.uniqueKeys=e,!t)throw ____errors0.noTypeProvided;this.type=t}get length(){return this.elements.length}get isEmpty(){return this.length<=0}get __last(){return this.elements[this.length-1]}getAll(){return this.elements}get(e){return this.elements[e]}clear(){this.elements=[]}removeFirst(){this.____splice(0)}removeLast(){this.____splice(this.length-1)}__isCorrectType(e){switch(this.type){case"any":return!0;case"int":return this.__isInt(e);case"float":return this.__isFloat(e);default:return typeof e===this.type}}__forEach(e){for(let t=0;t<this.elements.length;++t)e(this.elements[t])}____push(e){this.elements.push(e)}____splice(e){this.elements.splice(e,1)}__isInt(e){return"number"==typeof e&&e%1==0}__isFloat(e){return"number"==typeof e&&e%1!=0}}try{module.exports=Collection}catch(e){}try{____errors1=require("./errors"),____collection1=require("./collection")}catch(e){____errors1=Errors,____collection1=Collection}class Dictionary extends ____collection1{constructor(e){super(e,"any")}get lastValue(){try{return Object.values(this.__last)[0]}catch(e){return!1}}getAllValues(){let e=[];for(let t=0;t<this.elements.length;++t)e.push(Object.values(this.elements[t])[0]);return e}getAllKeys(){const e=[];for(let t=0;t<this.elements.length;++t)e.push(Object.keys(this.elements[t])[0]);return e}add(e,t){if(this.uniqueKeys&&!1!==this.findIndexOfKey(e))throw new Error(____errors1.existingKey);this.____push({[e]:t})}remove(e){const t=this.findIndexOfKey(e);return!1!==t&&(this.____splice(t,1),!0)}updateByKey(e,t){const r=this.findIndexOfKey(e);return!1!==r&&this.updateByIndex(r,t)}updateByIndex(e,t){try{return Object.defineProperty(this.elements[e],key,{value:t}),!0}catch(e){return!1}}getByIndex(e){return Object.values(this.elements[e])[0]}getKeyByIndex(e){return Object.keys(this.elements[e])[0]}getByKey(e){try{const t=this.____getElementAndIndexByKey(e);return!1!==t&&Object.values(t[1])[0]}catch(e){console.error(e)}}findIndexOfKey(e){const t=this.____getElementAndIndexByKey(e);return!1!==t&&t[0]}____getElementAndIndexByKey(e){let t;for(let r=0;r<this.elements.length;r++)if(t=this.elements[r],Object.keys(t)[0]===e)return[r,t];return!1}forEachValue(e){this.__forEach(t=>{e(Object.values(t)[0])})}}try{module.exports=Dictionary}catch(e){}try{____errors2=require("./errors"),____collection2=require("./collection")}catch(e){____errors2=Errors,____collection2=Collection}class List extends ____collection2{constructor(e){super(!1,e)}get last(){try{return this.__last}catch(e){return!1}}add(e){if(!1===this.__isCorrectType(e))throw ____errors2.wrongType(this.type);return this.____push(e)}update(e,t){if(!1===this.__isCorrectType(t))throw ____errors2.wrongType(this.type);this.elements[e]=t}contains(e){return this.elements.includes(e)}remove(e){this.splice(e)}forEach(e){this.__forEach(t=>{e(t)})}}try{module.exports=List}catch(e){}