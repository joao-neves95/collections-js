/*
 * Copyright (c) 2019-2020 Jo√£o Pedro Martins Neves - All Rights Reserved.
 *
 * js.system.collections is licensed under the MIT license,
 * located in the root of this project, under the name "LICENSE.md".
 *
 */

!function(e,t){"function"==typeof define&&define.amd?define("errors",[],t):"object"==typeof module&&module.exports?module.exports.Errors=t():e.Errors=t()}("undefined"!=typeof global?global:this.window||this.global,function(){return class{static get existingKey(){throw new Error("An item with the same key has already been added.")}static get noTypeProvided(){throw new Error("No type provided on Collection instantiation.")}static wrongType(e){throw new Error(`The value is not from the same type as the List<${e}>`)}}}),function(e,t){"function"==typeof define&&define.amd?define("collection",["errors"],t):"object"==typeof module&&module.exports?module.exports.Collection=t(require("./js.system.collections").Errors):e.Collection=t(e.Errors)}("undefined"!=typeof global?global:this.window||this.global,function(e){return class{constructor(t=!1,n="any"){if(this.elements=[],this.uniqueKeys=t,!n)throw e.noTypeProvided;this.type=n}get length(){return this.elements.length}get isEmpty(){return this.length<=0}get __last(){return this.elements[this.length-1]}getAll(){return this.elements}get(e){return this.elements[e]||!1}clear(){this.elements=[]}removeFirst(){this.____splice(0)}removeLast(){this.____splice(this.length-1)}__isCorrectType(e){switch(this.type){case"any":return!0;case"int":return this.__isInt(e);case"float":return this.__isFloat(e);default:return typeof e===this.type}}__forEach(e){for(let t=0;t<this.elements.length;++t)e(this.elements[t])}____push(e){this.elements.push(e)}____splice(e,t=1){this.elements.splice(e,t)}__isInt(e){return"number"==typeof e&&e%1==0}__isFloat(e){return"number"==typeof e&&e%1!=0}}}),function(e,t){if("function"==typeof define&&define.amd)define("dictionary",["collection","errors"],t);else if("object"==typeof module&&module.exports){const e=require("./js.system.collections");module.exports.Dictionary=t(e.Collection,e.Errors)}else e.Dictionary=t(e.Collection,e.Errors)}("undefined"!=typeof global?global:this.window||this.global,function(e,t){return class extends e{constructor(e){super(e,"any")}get lastValue(){try{return Object.values(this.__last)[0]}catch(e){return!1}}getAllValues(){let e=[];return this.forEachValue(t=>{e.push(t)}),e}getAllKeys(){const e=[];return this.__forEach(t=>{e.push(Object.keys(t)[0])}),e}containsKey(e){return!1!==this.findIndexOfKey(e)}add(e,n){if(this.uniqueKeys&&this.containsKey(e))throw new Error(t.existingKey);this.____push({[e]:n})}removeByIndex(e){return this.____splice(e),!0}remove(e){const t=this.findIndexOfKey(e);return!1!==t&&(this.____splice(t),!0)}updateByKey(e,t){const n=this.findIndexOfKey(e);return!1!==n&&this.updateByIndex(n,t)}updateByIndex(e,t){try{const n=this.elements[e];return Object.defineProperty(n,Object.keys(n)[0],{value:t}),!0}catch(e){return!1}}getByIndex(e){const t=this.elements[e];return null!=t&&Object.values(t)[0]}getKeyByIndex(e){const t=this.elements[e];return null!=t&&Object.keys(t)[0]}getByKey(e){try{const t=this.____getElementAndIndexByKey(e);return!1!==t&&Object.values(t[1])[0]}catch(e){return!1}}findIndexOfKey(e){const t=this.____getElementAndIndexByKey(e);return!1!==t&&t[0]}____getElementAndIndexByKey(e){let t;for(let n=0;n<this.elements.length;n++)if(t=this.elements[n],Object.keys(t)[0]===e)return[n,t];return!1}forEachValue(e){this.__forEach(t=>{e(Object.values(t)[0])})}}}),function(e,t){"function"==typeof define&&define.amd?define("list",["collection"],t):"object"==typeof module&&module.exports?module.exports.List=t(require("./js.system.collections").Collection):e.List=t(e.Collection)}("undefined"!=typeof global?global:this.window||this.global,function(e){return class extends e{constructor(e){super(!1,e)}get last(){try{return this.__last}catch(e){return!1}}add(e){if(!1===this.__isCorrectType(e))throw ____errors2.wrongType(this.type);return this.____push(e)}update(e,t){if(!1===this.__isCorrectType(t))throw ____errors2.wrongType(this.type);this.elements[e]=t}contains(e){return this.elements.includes(e)}remove(e){this.splice(e)}forEach(e){this.__forEach(t=>{e(t)})}}});